# 벨만포드 알고리즘
음의 가중치가 존재할 때 사용할 수 있는 알고리즘이다. 음의 사이클도 찾을 수 있다.

```cpp
    adj[S][S] = 0;        //시작점을 기준점으로 -> 0을 할당, 엣지가 있는 곳외에는 무한대 초기화 
    dist[S] = 0;        //dist배열은 가중치가 저장됨, 나머지는 무한대로 초기화
    
    for (int v = 1; v <= V-1; v++) {// 노드수-1번 돌아가야 한다. N-1번 거친다는 의미
        for (int w = 1; w <=V; w++) {// 각 노드의 엣지수만큼 돌아야 한다.
            if (v != w && adj[v][w] != INF) {
                if (dist[w] > dist[v] + adj[v][w])
                    dist[w] = dist[v] + adj[v][w];
                //만약, 음수가중치가 있어서 현재 가중치보다
                //작은 가중치가 생길경우 업데이트함 
            }
        }
    }
 //만약, 위의 노드수 -1번 외에 한번 더 확인할때, s->e로 가는 길이 있고 가중치가 v하고 가정
 //dist[s] + v < dist[e] 인 경우가 있다면 모순, 즉 음수 사이클이 존재
 //n번째에도 업데이트를 하게 되면 음의 사이클이 존재하는 것!


```